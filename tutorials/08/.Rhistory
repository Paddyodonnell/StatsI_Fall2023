n_y <- length(y)
# Calculate the sample standard errors
se_x <- sqrt(var_x/n_x)
se_y <- sqrt(var_y/n_y)
se <- sqrt(se_x^2 + se_y^2)
# Calculate the t-statistic
t_stat <- (mean_x - mean_y) / se
# Calculate the degrees of freedom
df <- se^4/(se_x^4/(n_x - 1) + se_y^4/(n_y - 1))
# Calculate the p-value
p_val <- 2 * (1 - pt(abs(t_stat), df))
# Create a result list
res <- list(
t_statistic = t_stat,
degrees_of_freedom = df,
p_value = p_val
)
return(res)
}
t_test <- function(x, y)
# Calculate the means of the two samples
mean_x <- mean(x)
mean_y <- mean(y)
# Calculate the variances of the two samples
var_x <- var(x)
var_y <- var(y)
|m|
pearson <- function(vec_x, vec_y) {
if (!(is.numeric(vec_x) & is.numeric(vec_y))) {
stop("Both arguments must be numeric")
}
mean_x <- sum(vec_x)/length(vec_x)
mean_y <- sum(vec_y)/length(vec_y)
numerator <- sum((vec_x - mean_x) * (vec_y - mean_y))
denominator <- (
sum((vec_x - mean_x)^2)^1/2 *
sum((vec_y - mean_y)^2)^1/2
)
r <- numerator/denominator
# Make sure that floating point arithmetic does not
# produce absolute values larger than 1
r <- max(min(r, 1.0), -1.0)
return(r)
}
return(r)
return(r)
pearson <- function(vec_x, vec_y) {
if (!(is.numeric(vec_x) & is.numeric(vec_y))) {
stop("Both arguments must be numeric")
}
mean_x <- sum(vec_x)/length(vec_x)
mean_y <- sum(vec_y)/length(vec_y)
numerator <- sum((vec_x - mean_x) * (vec_y - mean_y))
denominator <- (
sum((vec_x - mean_x)^2)^1/2 *
sum((vec_y - mean_y)^2)^1/2
)
r <- numerator/denominator
# Make sure that floating point arithmetic does not
# produce absolute values larger than 1
r <- max(min(r, 1.0), -1.0)
return(r)
}
if (!(is.numeric(vec_x) & is.numeric(vec_y))) {
stop("Both arguments must be numeric")
}
pearson <- function(vec_x, vec_y) {
if (!(is.numeric(vec_x) & is.numeric(vec_y))) {
stop("Both arguments must be numeric")
}
mean_x <- sum(vec_x)/length(vec_x)
mean_y <- sum(vec_y)/length(vec_y)
numerator <- sum((vec_x - mean_x) * (vec_y - mean_y))
denominator <- (
sum((vec_x - mean_x)^2)^1/2 *
sum((vec_y - mean_y)^2)^1/2
)
r <- numerator/denominator
# Make sure that floating point arithmetic does not
# produce absolute values larger than 1
r <- max(min(r, 1.0), -1.0)
return(r)
}
pearson <- function(vec_x, vec_y)
if (!(is.numeric(vec_x) & is.numeric(vec_y))) {
stop("Both arguments must be numeric")
}
stop("Both arguments must be numeric")
mean_x <- sum(vec_x)/length(vec_x)
mean_y <- sum(vec_y)/length(vec_y)
pearson <- function(vec_x, vec_y) {
if (!(is.numeric(vec_x) & is.numeric(vec_y))) {
stop("Both arguments must be numeric")
mean_x <- sum(vec_x)/length(vec_x)
mean_y <- sum(vec_y)/length(vec_y)
numerator <- sum((vec_x - mean_x) * (vec_y - mean_y))
denominator <- (
sum((vec_x - mean_x)^2)^1/2 *
sum((vec_y - mean_y)^2)^1/2
)
r <- numerator/denominator
# Make sure that floating point arithmetic does not
# produce absolute values larger than 1
r <- max(min(r, 1.0), -1.0)
return(r)
View(r)
print(r)
pearson(c(1, 2, 3, 4, 5),c(-3, -5, -7, -9, -11))
cor(c(1, 2, 3, 4, 5),c(-3, -5, -7, -9, -11))
pearson(c(1, 2, 3, 4, 5),c(-3, -5, -7, -9, -11))
1+1
1+1=
pearson(c(1, 2, 3, 4, 5),c(-3, -5, -7, -9, -11))
cor(c(1, 2, 3, 4, 5),c(-3, -5, -7, -9, -11))
2*2
a <- letter
print(a)
print(t_test)
a <- letter
print(a)
a <- b
1+1
pearson(c(1, 2, 3, 4, 5),c(-3, -5, -7, -9, -11))
pearson <- function(vec_x, vec_y) {
if (!(is.numeric(vec_x) & is.numeric(vec_y))) {
stop("Both arguments must be numeric")
}
mean_x <- sum(vec_x)/length(vec_x)
mean_y <- sum(vec_y)/length(vec_y)
numerator <- sum((vec_x - mean_x) * (vec_y - mean_y))
denominator <- (
sum((vec_x - mean_x)^2)^1/2 *
sum((vec_y - mean_y)^2)^1/2
)
r <- numerator/denominator
# Make sure that floating point arithmetic does not
# produce absolute values larger than 1
r <- max(min(r, 1.0), -1.0)
return(r)
}
pearson(c(1, 2, 3, 4, 5),c(-3, -5, -7, -9, -11))
cor(c(1, 2, 3, 4, 5),c(-3, -5, -7, -9, -11))
pearson(c(1, 2, 3, 4, 5),c(-3, -5, -7, -9, -11) method = pearson)
pearson(c(1, 2, 3, 4, 5),c(-3, -5, -7, -9, -11), method = pearson)
cor(c(1, 2, 3, 4, 5),c(-3, -5, -7, -9, -11), method = pearson)
cor(c(1, 2, 3, 4, 5),c(-3, -5, -7, -9, -11), method = pearson)
cor(c(1, 2, 3, 4, 5),c(-3, -5, -7, -9, -11))
pearson <- function(vec_x, vec_y) {
if (!(is.numeric(vec_x) & is.numeric(vec_y))) {
stop("Both arguments must be numeric")
}
mean_x <- sum(vec_x)/length(vec_x)
mean_y <- sum(vec_y)/length(vec_y)
numerator <- sum((vec_x - mean_x) * (vec_y - mean_y))
denominator <- (
sqrt(sum(vec_x - mean_x)^2)) *
sqrt(sum(vec_y - mean_y)^2))
pearson <- function(vec_x, vec_y) {
if (!(is.numeric(vec_x) & is.numeric(vec_y))) {
stop("Both arguments must be numeric")
}
mean_x <- sum(vec_x)/length(vec_x)
mean_y <- sum(vec_y)/length(vec_y)
numerator <- sum((vec_x - mean_x) * (vec_y - mean_y))
denominator <- (
sqrt(sum(vec_x - mean_x)^2) *
sqrt(sum(vec_y - mean_y)^2)
)
r <- numerator/denominator
# Make sure that floating point arithmetic does not
# produce absolute values larger than 1
r <- max(min(r, 1.0), -1.0)
return(r)
}
pearson(c(1, 2, 3, 4, 5),c(-3, -5, -7, -9, -11))
cor(c(1, 2, 3, 4, 5),c(-3, -5, -7, -9, -11))
?punct
??punct
help("punct")
[:punct:]
gsub([:punct:])
gsub(:punct:)
gsub(punct)
t_test <- function(x, y) {
# Calculate the means of the two samples
mean_x <- mean(x)
mean_y <- mean(y)
# Calculate the variances of the two samples
var_x <- var(x)
var_y <- var(y)
# Calculate the sample sizes
n_x <- length(x)
n_y <- length(y)
# Calculate the sample standard errors
se_x <- sqrt(var_x/n_x)
se_y <- sqrt(var_y/n_y)
se <- sqrt(se_x^2 + se_y^2)
# Calculate the t-statistic
t_stat <- (mean_x - mean_y) / se
# Calculate the degrees of freedom
df <- se^4/(se_x^4/(n_x - 1) + se_y^4/(n_y - 1))
# Calculate the p-value
p_val <- 2 * (1 - pt(abs(t_stat), df))
# Create a result list
res <- list(
t_statistic = t_stat,
degrees_of_freedom = df,
p_value = p_val
)
return(res)
}
pearson <- function(vec_x, vec_y) {
if (!(is.numeric(vec_x) & is.numeric(vec_y))) {
stop("Both arguments must be numeric")
}
mean_x <- sum(vec_x)/length(vec_x)
mean_y <- sum(vec_y)/length(vec_y)
numerator <- sum((vec_x - mean_x) * (vec_y - mean_y))
print(numerator)
denominator <- (
(sum(vec_x - mean_x)^2)^1/2 *
(sum(vec_y - mean_y)^2)^1/2
)
print(denominator)
r <- numerator/denominator
print(r)
# Make sure that floating point arithmetic does not
# produce absolute values larger than 1
r <- max(min(r, 1.0), -1.0)
return(r)
}
pearson(c(1, 2, 3, 4, 5),c(-3, -5, -7, -9, -11))
pearson(c(1, 2, 3, 4, 5),c(-3, -5, -7, -9, -11))
?!
help("!")
fibinacci_indices <- function(num_vector){
if(!is.numeric(num_vector) || any(num_vec %% 1 != 0)){
stop("Vector must be completely numeric")
}
if(any(num_vector <= 0)){
stop("vector must contain positives integers")
}
fibinancci <- function(n){
if(n <= 1){
return(n)
} else {
return(fibinancci(n-1) + fibinancci(n-2))
}
}
fibinacci_numbers <- sapply(num_vector, function(index) fibinancci(index-1))
return(fibinacci_numbers)
}
fibinacci_indices(10)
fibinacci_indices <- function(num_vector){
if(!is.numeric(num_vector) || any(num_vector %% 1 != 0)){
stop("Vector must be completely numeric")
}
if(any(num_vector <= 0)){
stop("vector must contain positives integers")
}
fibinancci <- function(n){
if(n <= 1){
return(n)
} else {
return(fibinancci(n-1) + fibinancci(n-2))
}
}
fibinacci_numbers <- sapply(num_vector, function(index) fibinancci(index-1))
return(fibinacci_numbers)
}
fibinacci_indices(10)
fibinacci_indices(c(1, 2, 3, 4, 5))
fibinacci_indices(c(3, 9, 12))
fibinacci_indices <- function(num_vector){
if(!is.numeric(num_vector) || any(num_vector %% 1 != 0)){
stop("Vector must be completely numeric")
}
if(any(num_vector <= 0)){
stop("vector must contain only positives integers")
}
fibinancci <- function(n){
if(n <= 1){
return(n)
} else {
return(fibinancci(n-1) + fibinancci(n-2))
}
}
fibinacci_numbers <- sapply(num_vector, function(index) fibinancci(index-1))
return(fibinacci_numbers)
}
fibinacci_indices(10)
fibinacci_indices(c(1, 2, 3, 4, 5))
fibinacci_indices(c(3, 9, 12))
fibinacci_indices(1000)
fibinacci_indices <- function(num_vector){
if(!is.numeric(num_vector) || any(num_vector %% 1 != 0)){
stop("Vector must be completely numeric")
}
if(any(num_vector <= 0)){
stop("vector must contain only positives integers")
}
fibinancci <- function(n){
if(n <= 1){
return(n)
} else {
return(fibinancci(n-1) + fibinancci(n-2))
}
}
fibinacci_numbers <- sapply(num_vector, function(index) fibinancci(index-1))
return(fibinacci_numbers)
}
fibinacci_indices(100)
fibinacci_indices <- function(num_vector){
if(!is.numeric(num_vector) || any(num_vector %% 1 != 0)){
stop("Vector must be completely numeric")
}
if(any(num_vector <= 0)){
stop("vector must contain only positives integers")
}
fibinancci <- function(n){
if(n <= 1){
return(n)
} else {
return(fibinancci(n-1) + fibinancci(n-2))
}
}
fibinacci_numbers <- sapply(num_vector, function(index) fibinancci(index-1))
return(fibinacci_numbers)
}
fibinacci_indices(10)
fibinacci_indices(c(1, 2, 3, 4, 5))
fibinacci_indices(c(3, 9, 12))
fibinacci_indices(100)
fibinacci_indices <- function(num_vector){
if(!is.numeric(num_vector) || any(num_vector %% 1 != 0)){
stop("Vector must be completely numeric")
}
if(any(num_vector <= 0)){
stop("vector must contain only positives integers")
}
fibinancci <- function(n){
if(n <= 1){
return(n)
} else {
return(fibinancci(n-1) + fibinancci(n-2))
}
}
fibinacci_numbers <- sapply(num_vector, function(index) fibinancci(index-1))
return(fibinacci_numbers)
}
fibinacci_indices(1,3,6)
fibinacci_indices(c(1,3,6))
{languages_questions <- data[, c("Q12_1", "Q12_2", "Q12_3", "Q12_4", "Q12_5", "Q12_6", "Q12_7", "Q12_8", "Q12_9", "Q12_10", "Q12_11", "Q12_12", "Q12_13", "Q12_14", "Q12_15")]
language_counts <- as.data.frame(table(unlist(languages_questions)))
final_languages <- language_counts[2:15, 2]
respondents <- (nrow(data)-1)
percentages <- (final_languages/respondents)*100
print(percentages)
}
data <- read.csv("C:/Users/paddy/Downloads/kaggle_survey_2022_responses.csv")
{languages_questions <- data[, c("Q12_1", "Q12_2", "Q12_3", "Q12_4", "Q12_5", "Q12_6", "Q12_7", "Q12_8", "Q12_9", "Q12_10", "Q12_11", "Q12_12", "Q12_13", "Q12_14", "Q12_15")]
language_counts <- as.data.frame(table(unlist(languages_questions)))
final_languages <- language_counts[2:15, 2]
respondents <- (nrow(data)-1)
percentages <- (final_languages/respondents)*100
print(percentages)
}
str(csv)
str(percentages)
order(percentages, decreasing = TRUE)
sort(percentages, decreasing = TRUE)
View(language_counts)
language_counts[2:15, 1]
sorted_percentages <- percentages[sorted_indices]
{languages_questions <- data[, c("Q12_1", "Q12_2", "Q12_3", "Q12_4", "Q12_5", "Q12_6", "Q12_7", "Q12_8", "Q12_9", "Q12_10", "Q12_11", "Q12_12", "Q12_13", "Q12_14", "Q12_15")]
language_counts <- as.data.frame(table(unlist(languages_questions)))
final_languages <- language_counts[2:15, 2]
respondents <- (nrow(data)-1)
percentages <- (final_languages/respondents)*100
print(percentages)
sorted_indices <- sort(percentages, decreasing = TRUE)
}
sorted_percentages <- percentages[sorted_indices]
sorted_language_names <- names(final_languages)[sorted_indices]
print(sorted_percentages)
print(sorted_language_names)
sorted_language_names <- Var1(final_languages)[sorted_indices]
{languages_questions <- data[, c("Q12_1", "Q12_2", "Q12_3", "Q12_4", "Q12_5", "Q12_6", "Q12_7", "Q12_8", "Q12_9", "Q12_10", "Q12_11", "Q12_12", "Q12_13", "Q12_14", "Q12_15")]
language_counts <- as.data.frame(table(unlist(languages_questions)))
final_languages <- language_counts[2:15, 2]
respondents <- (nrow(data)-1)
percentages <- (final_languages/respondents)*100
print(percentages)
sorted_percentages <- sort(percentages, decreasing = TRUE)
print(sorted_percentages)
}
language_counts[2:15, 1]
srt(language_counts)
str(language_counts)
language_counts[2:15]
language_counts[2:15, 1:2]
as.data.frame(language_counts[2:15, 1:2])
new_df <- as.data.frame(language_counts[2:15, 1:2])
sorted_df <- new_df[order(-new_df$Freq), ]
print(sorted_df)
# Set working directory as path where file is located
getwd()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
# Install and load packages
# Adopted from: https://stackoverflow.com/questions/4090169/elegant-way-to-check-for-missing-packages-and-install-them
if(!require(wbstats)){
install.packages("wbstats")
library(wbstats)}
if(!require(tidyverse)){
install.packages("tidyverse")
library(tidyverse)}
if(!require(ggplot2)){
install.packages("ggplot2")
library(ggplot2)}
if(!require(stargazer)){
install.packages("stargazer")
library(stargazer)}
# Load zipped data from url
if(!require(readr)){
install.packages("readr")
library(readr)}
# Load data from World Bank API
wb <- wb(country=c("AF","BRA","ITA","NGA","SWE","UGA"),
indicator=c("NY.GDP.PCAP.CD", # GDP per capita (current US$)
"SP.POP.TOTL", # Population, total
"SE.SEC.ENRR", #  School enrollment, secondary (% gross)
"SH.DYN.MORT"), # Mortality rate, under-5 (per 1,000 live births)
startdate = 2000, enddate = 2020)
# Reshape data from long to wide
wb_re <- reshape(wb[, c("country","iso3c","date","indicatorID","value")], # df
timevar = "indicatorID",
idvar = c("country","date","iso3c"),
direction = "wide")
# Load Quality of Government data
qog <- read_csv("https://www.qogdata.pol.gu.se/data/qog_bas_ts_jan23.csv")
# Merge
df <- merge(wb_re, # Left df
qog[, c("ccodealp","year","bmr_dem")], # Right df
by.x=c("date","iso3c"), # merge variables in left
by.y=c("year","ccodealp"), # merge variables in right
all.x=TRUE, # merge operation, only keep left
sort=FALSE) # Do not sort observations
View(wb_re)
# Load Quality of Government data
qog <- read_csv("https://www.qogdata.pol.gu.se/data/qog_bas_ts_jan23.csv")
View(qog)
# Merge
df <- merge(wb_re, # Left df
qog[, c("ccodealp","year","bmr_dem")], # Right df
by.x=c("date","iso3c"), # merge variables in left
by.y=c("year","ccodealp"), # merge variables in right
all.x=TRUE, # merge operation, only keep left
sort=FALSE) # Do not sort observations
# Rename columns
names(df)
names(df)[4] <- "gdp_per_cap"
names(df)[5] <- "pop_size"
names(df)[6] <- "sec_enrol"
names(df)[7] <- "mort"
names(df)[8] <- "democracy"
View(df)
# Save df
write.csv(df, "df_income_mortality.csv")
# Load df
df <- read_csv("df_income_mortality_best.csv")
View(df)
# Load df
df <- read_csv("df_income_mortality_best.csv")
# Get unique countries in df
df_uni <- select(df, country) # Select variable
df_uni <- distinct(df_uni, country) # Get unique values
df_uni
# Get unique countries in df, using the pipe
df %>%
select(country) %>%
distinct(country)
# Filter (subset is base R)
df_s <- filter(df, country %in% c("Afghanistan","Italy"))
df_s
read.csv("C:\Users\paddy\Downloads\kaggle_survey_2022_responses (1).csv")
read.csv("C:/Users/paddy/Downloads/kaggle_survey_2022_responses (1).csv")
data <- read.csv("C:/Users/paddy/Downloads/kaggle_survey_2022_responses (1).csv")
View(data)
{languages_questions <- data[, c("Q12_1", "Q12_2", "Q12_3", "Q12_4", "Q12_5", "Q12_6", "Q12_7", "Q12_8", "Q12_9", "Q12_10", "Q12_11", "Q12_12", "Q12_13", "Q12_14", "Q12_15")]
language_counts <- as.data.frame(table(unlist(languages_questions)))
final_languages <- language_counts[2:15, 2]
respondents <- (nrow(data)-1)
percentages <- (final_languages/respondents)*100
print(percentages)
sorted_percentages <- sort(percentages, decreasing = TRUE)
print(sorted_percentages)
#Sort the languages by popularity.
new_df <- as.data.frame(language_counts[2:15, 1:2])
sorted_df <- new_df[order(-new_df$Freq), ]
print(sorted_df)
}
nrow(data)
nrow(data)-1
ncol(data)
srt(data)
str(data)
# Install and load packages
# Adopted from: https://stackoverflow.com/questions/4090169/elegant-way-to-check-for-missing-packages-and-install-them
if(!require(mvtnorm)){
install.packages("mvtnorm")
library(mvtnorm)}
